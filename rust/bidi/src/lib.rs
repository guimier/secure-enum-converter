#![deny(missing_docs)]
//! Conversion between similar enums made easy.
//!
//! This crate provides two traits that are intended to be implemented by the
//! `bidi` macro provided by the `bidi-codegen` crate.
//!
//! Sometimes, you have enums that come from different contexts with the same
//! or almost the same members and you want to convert between the two contexts
//! forth and back. Unfortunately, the easiest solutions to this problem imply
//! either to lose compile-time guarantees, or to maintain two mappings that can
//! get out of sync. The `bidi` macro takes a single mapping and expands to two
//! mapping methods, one for each direction.
//!
//! Basic use looks as follows:
//! ```
//! # #![feature(proc_macro_hygiene)] // WTF?
//! use bidi_codegen::*;
//! use bidi::*;
//!
//! mod first {
//!     #[derive(PartialEq, Debug)]
//!     pub enum L3Protocol { IpV4, IpV6 }
//! }
//! mod second {
//!     #[derive(PartialEq, Debug)]
//!     pub enum L3Protocol { Ip4, Ip6 }
//! }
//!
//! bidi!(Converter<first::L3Protocol, second::L3Protocol> {
//!     IpV4 == Ip4,
//!     IpV6 == Ip6,
//! });
//!
//! assert_eq!(Converter::convert(&first::L3Protocol::IpV4), second::L3Protocol::Ip4);
//! assert_eq!(Converter::convert(&second::L3Protocol::Ip4), first::L3Protocol::IpV4);
//! ```
//!
//! Because the conversion may not be perfect, additional syntax is provided:
//! ```
//! # #![feature(proc_macro_hygiene)] // WTF?
//! # use bidi_codegen::*;
//! # use bidi::*;
//! #
//! # #[derive(PartialEq, Debug)]
//! enum First { Matching1, Projected1, Orphan1 };
//! # #[derive(PartialEq, Debug)]
//! enum Second { Matching2, Projected2, Orphan2 };
//!
//! bidi!(Converter<First, Second> {
//!     // `Matching1` is converted to `Matching2` *and* `Matching2` is
//!     // converted to `Matching1`. This is the most common case.
//!     Matching1  == Matching2,
//!     // `Projected2` is converted to `Matching1`, but `Matching1` conversion
//!     // is defined by another rule.
//!     Matching1  <= Projected2,
//!     // `Projected1` is converted to `Matching2`, but `Matching2` conversion
//!     // is defined by another rule.
//!     Projected1 => Matching2,
//!     // `Orphan1` is not convertible.
//!     Orphan1    => _,
//!     // `Orphan2` is not convertible.
//!     _          <= Orphan2
//! });
//! ```

/// The `PartialEnumConverter` trait is the most generic trait, that is
/// implemented for all types generated by `bidi`, in both direction.
/// i.e. given `bidi!(Foo<Bar, Baz> { … });` the `Foo` type will implement both
/// `PartialEnumConverter<Bar, Baz>` and `PartialEnumConverter<Baz, Bar>`.
pub trait PartialEnumConverter<FromType, ToType> {
    /// This methods returns the matching value for `from_value` according to
    /// the mapping, or `None` in case of an orphan member.
    fn convert_opt(from_value: &FromType) -> Option<ToType>;
    /// This method returns all the values of the `FromType` that can be
    /// converted (i.e. `convert_opt` won’t return `None`).
    fn convertible_values() -> &'static [FromType];
}

/// The `EnumConverter` trait will only be implemented for conversions that have
/// no orphans. Unlike `PartialEnumConverter` that is always implemented in both
/// directions, `EnumConverter` may be implemented for both sides, none, or only
/// one, depending on the presence of orphan rules in the mapping.
pub unsafe trait EnumConverter<FromType, ToType>:
    PartialEnumConverter<FromType, ToType>
{
    /// This method is a convenience method that can be used only when the
    /// underlying mapping has no orphan rule (i.e. the `convert_opt` cannot
    /// return `None`).
    fn convert(from_value: &FromType) -> ToType {
        Self::convert_opt(from_value).unwrap()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bidi_codegen::*;

    #[derive(Debug, Eq, PartialEq)]
    enum A {
        A1,
        A2,
    }
    #[derive(Debug, Eq, PartialEq)]
    enum B {
        B1,
        B2,
    }

    #[derive(Debug, Eq, PartialEq)]
    enum C {
        C1,
        C2,
        C3,
    }

    bidi!(* DirectConverter<A, B> {
        A1 == B1,
        A2 == B2,
    });

    bidi!(* ReversedConverter<A, B> {
        A1 == B2,
        A2 == B1,
    });

    bidi!(* SemiCompleteConverter<A,C> {
        A1 == C1,
        A2 == C2,
        _  <= C3
    });

    bidi!(* ProjectedConverter<A,C> {
        A1 == C1,
        A2 == C2,
        A1 <= C3
    });

    #[test]
    fn direct_convertible_values() {
        assert_eq!(
            <DirectConverter as PartialEnumConverter<A, B>>::convertible_values(),
            [A::A1, A::A2]
        );
        assert_eq!(
            <DirectConverter as PartialEnumConverter<B, A>>::convertible_values(),
            [B::B1, B::B2]
        );
    }

    #[test]
    fn reversed_convertible_values() {
        assert_eq!(
            <ReversedConverter as PartialEnumConverter<A, B>>::convertible_values(),
            [A::A1, A::A2]
        );
        assert_eq!(
            <ReversedConverter as PartialEnumConverter<B, A>>::convertible_values(),
            [B::B2, B::B1]
        );
    }

    #[test]
    fn semi_complete_convertible_values() {
        assert_eq!(
            <SemiCompleteConverter as PartialEnumConverter<A, C>>::convertible_values(),
            [A::A1, A::A2]
        );
        assert_eq!(
            <SemiCompleteConverter as PartialEnumConverter<C, A>>::convertible_values(),
            [C::C1, C::C2]
        );
    }

    #[test]
    fn projected_convertible_values() {
        assert_eq!(
            <ProjectedConverter as PartialEnumConverter<A, C>>::convertible_values(),
            [A::A1, A::A2]
        );
        assert_eq!(
            <ProjectedConverter as PartialEnumConverter<C, A>>::convertible_values(),
            [C::C1, C::C2, C::C3]
        );
    }

    #[test]
    fn direct_opt_conversions() {
        // First direction
        assert_eq!(DirectConverter::convert_opt(&A::A1), Some(B::B1));
        assert_eq!(DirectConverter::convert_opt(&A::A2), Some(B::B2));
        // Second direction
        assert_eq!(DirectConverter::convert_opt(&B::B1), Some(A::A1));
        assert_eq!(DirectConverter::convert_opt(&B::B2), Some(A::A2));
    }

    #[test]
    fn direct_conversions() {
        // First direction
        assert_eq!(DirectConverter::convert(&A::A1), B::B1);
        assert_eq!(DirectConverter::convert(&A::A2), B::B2);
        // Second direction
        assert_eq!(DirectConverter::convert(&B::B1), A::A1);
        assert_eq!(DirectConverter::convert(&B::B2), A::A2);
    }

    #[test]
    fn reversed_opt_conversions() {
        // First direction
        assert_eq!(ReversedConverter::convert_opt(&A::A1), Some(B::B2));
        assert_eq!(ReversedConverter::convert_opt(&A::A2), Some(B::B1));
        // Second direction
        assert_eq!(ReversedConverter::convert_opt(&B::B2), Some(A::A1));
        assert_eq!(ReversedConverter::convert_opt(&B::B1), Some(A::A2));
    }

    #[test]
    fn reversed_conversions() {
        // First direction
        assert_eq!(ReversedConverter::convert(&A::A1), B::B2);
        assert_eq!(ReversedConverter::convert(&A::A2), B::B1);
        // Second direction
        assert_eq!(ReversedConverter::convert(&B::B2), A::A1);
        assert_eq!(ReversedConverter::convert(&B::B1), A::A2);
    }

    #[test]
    fn semi_complete_opt_conversions() {
        // First direction
        assert_eq!(SemiCompleteConverter::convert_opt(&A::A1), Some(C::C1));
        assert_eq!(SemiCompleteConverter::convert_opt(&A::A2), Some(C::C2));
        // Second direction
        assert_eq!(SemiCompleteConverter::convert_opt(&C::C1), Some(A::A1));
        assert_eq!(SemiCompleteConverter::convert_opt(&C::C2), Some(A::A2));
        assert_eq!(SemiCompleteConverter::convert_opt(&C::C3), None);
    }

    #[test]
    fn projected_opt_conversions() {
        // First direction
        assert_eq!(ProjectedConverter::convert_opt(&A::A1), Some(C::C1));
        assert_eq!(ProjectedConverter::convert_opt(&A::A2), Some(C::C2));
        // Second direction
        assert_eq!(ProjectedConverter::convert_opt(&C::C1), Some(A::A1));
        assert_eq!(ProjectedConverter::convert_opt(&C::C2), Some(A::A2));
        assert_eq!(ProjectedConverter::convert_opt(&C::C3), Some(A::A1));
    }

    #[test]
    fn projected_conversions() {
        // First direction
        assert_eq!(ProjectedConverter::convert(&A::A1), C::C1);
        assert_eq!(ProjectedConverter::convert(&A::A2), C::C2);
        // Second direction
        assert_eq!(ProjectedConverter::convert(&C::C1), A::A1);
        assert_eq!(ProjectedConverter::convert(&C::C2), A::A2);
        assert_eq!(ProjectedConverter::convert(&C::C3), A::A1);
    }
}
